"""
nexsus/core/waf_detector.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Multi-signal WAF / security layer detector.

Detection strategy (layered):
  1. Passive header / cookie fingerprinting
  2. Body signature matching
  3. Active probe: send a benign canary payload and analyse the block response
  4. Timing analysis (challenge pages introduce latency)
  5. Confidence-scored result → only report when score ≥ threshold

Supported WAFs / CDNs:
  Cloudflare, Akamai, AWS WAF, Azure Application Gateway,
  F5 BIG-IP ASM, Imperva Incapsula, Sucuri, ModSecurity,
  Nginx ModSecurity, Fastly, Varnish, Barracuda, Fortinet FortiWeb,
  Wordfence, Palo Alto Prisma (formerly Zingbox), Wallarm, HAProxy
"""
import asyncio
import re
import time
from dataclasses import dataclass, field
from typing import Optional

from nexsus.core.logger import Logger


@dataclass
class WAFResult:
    name:       str
    confidence: int        # 0–100
    signals:    list[str]  = field(default_factory=list)
    active:     bool       = False  # triggered by active probe?

    def __repr__(self) -> str:
        return f"<WAF {self.name!r} conf={self.confidence} signals={self.signals}>"


_SIGNATURES: dict[str, dict] = {
    # ── CDN / Cloud WAFs ──────────────────────────────────────────────────────
    "cloudflare": {
        "headers":    ["cf-ray", "cf-cache-status", "cf-request-id", "cf-worker"],
        "cookies":    ["__cfduid", "__cf_bm", "cf_clearance"],
        "body":       [
            r"cloudflare", r"cf-error-code", r"cf-challenge",
            r"attention required.*cloudflare", r"managed by cloudflare",
            r"error 1006", r"error 1010", r"error 1015",
        ],
        "status":     [403, 503, 429],
        "weights":    {"headers": 20, "cookies": 20, "body": 30, "status": 5},
    },
    "akamai": {
        "headers":    ["x-akamai-transformed", "x-akamai-request-id", "x-check-cacheable", "akamai-grn"],
        "cookies":    ["_abck", "bm_sz", "ak_bmsc"],
        "body":       [r"akamai", r"reference #\d+\.\w+", r"access denied", r"ghost-.*akamai"],
        "status":     [403, 401],
        "weights":    {"headers": 25, "cookies": 25, "body": 25, "status": 5},
    },
    "aws_waf": {
        "headers":    ["x-amzn-requestid", "x-amzn-errortype", "x-amzn-trace-id"],
        "cookies":    ["aws-waf-token", "awsalb", "awsalbcors"],
        "body":       [r"aws waf", r"request blocked", r"403 forbidden.*aws", r"x-amzn-errortype"],
        "status":     [403],
        "weights":    {"headers": 30, "cookies": 20, "body": 30, "status": 5},
    },
    "azure_waf": {
        "headers":    ["x-ms-request-id", "x-ms-correlation-request-id", "x-azure-ref"],
        "cookies":    ["azurewebapp", "arr-disable-session-affinity"],
        "body":       [r"azure application gateway", r"application gateway", r"microsoft azure"],
        "status":     [403, 404],
        "weights":    {"headers": 25, "cookies": 10, "body": 30, "status": 5},
    },
    "fastly": {
        "headers":    ["fastly-restarts", "fastly-debug-digest", "x-served-by", "x-cache", "x-fastly-request-id"],
        "cookies":    [],
        "body":       [r"fastly error:", r"fastly", r"varnish"],
        "status":     [503],
        "weights":    {"headers": 30, "cookies": 0, "body": 20, "status": 5},
    },
    # ── Hardware / On-Prem WAFs ───────────────────────────────────────────────
    "f5_bigip": {
        "headers":    ["x-iinfo", "bigipserver", "x-wa-info"],
        "cookies":    ["ts", "bigipserver", "f5avr"],
        "body":       [r"f5 networks", r"big-ip", r"the requested url was rejected", r"please consult.*support id"],
        "status":     [403, 500],
        "weights":    {"headers": 20, "cookies": 20, "body": 35, "status": 5},
    },
    "imperva": {
        "headers":    ["x-iinfo", "x-cdn"],
        "cookies":    ["incap_ses", "visid_incap", "nlbi_"],
        "body":       [r"incapsula", r"imperva", r"blocked because of malicious activity", r"request unsuccessful"],
        "status":     [403],
        "weights":    {"headers": 15, "cookies": 35, "body": 30, "status": 5},
    },
    "sucuri": {
        "headers":    ["x-sucuri-id", "x-sucuri-cache"],
        "cookies":    ["sucuri_cloudproxy"],
        "body":       [r"sucuri", r"cloudproxy", r"access denied - sucuri"],
        "status":     [403],
        "weights":    {"headers": 30, "cookies": 20, "body": 30, "status": 5},
    },
    "modsecurity": {
        "headers":    ["server"],  # checked for mod_security in value
        "cookies":    [],
        "body":       [r"modsecurity", r"mod_security", r"this error was generated by mod_security", r"not acceptable"],
        "status":     [403, 406, 501],
        "weights":    {"headers": 5, "cookies": 0, "body": 40, "status": 10},
    },
    "barracuda": {
        "headers":    ["x-barracuda-start-time"],
        "cookies":    ["barra_counter_session"],
        "body":       [r"barracuda", r"barracuda networks", r"barra_counter"],
        "status":     [400, 403],
        "weights":    {"headers": 20, "cookies": 20, "body": 35, "status": 5},
    },
    "fortiweb": {
        "headers":    ["x-iid"],
        "cookies":    ["cookiesession1"],
        "body":       [r"fortinet", r"fortiweb", r"web application firewall"],
        "status":     [403],
        "weights":    {"headers": 10, "cookies": 10, "body": 40, "status": 5},
    },
    "wallarm": {
        "headers":    ["x-wallarm-node"],
        "cookies":    [],
        "body":       [r"wallarm", r"blocked by wallarm"],
        "status":     [403],
        "weights":    {"headers": 40, "cookies": 0, "body": 35, "status": 5},
    },
    "wordfence": {
        "headers":    [],
        "cookies":    ["wordfence_verifiedHuman"],
        "body":       [r"wordfence", r"generated by wordfence", r"your access to this site has been limited"],
        "status":     [403],
        "weights":    {"headers": 0, "cookies": 25, "body": 45, "status": 5},
    },
}

# Canary payload that triggers most WAFs but is harmless
_PROBE_PATHS = [
    "/?q=<script>alert(1)</script>",
    "/?id=' OR '1'='1",
    "/?file=../../../../etc/passwd",
    "/?cmd=;id;",
]


class WAFDetector:
    """
    Detects Web Application Firewalls via passive and active probing.
    """

    CONFIDENCE_THRESHOLD = 30   # minimum score to report a WAF

    def __init__(self, http_client):
        self.http_client = http_client
        self.logger      = Logger("WAFDetector")

    # ── Public API ─────────────────────────────────────────────────────────────

    async def detect(self, url: str, active: bool = True) -> Optional[WAFResult]:
        """
        Detect WAF on *url*.

        Parameters
        ----------
        url : str
        active : bool
            If True, send an active probe after passive analysis.

        Returns
        -------
        WAFResult or None
        """
        self.logger.info(f"WAF detection on {url}")

        # 1) Passive — normal GET
        passive_results = await self._passive_probe(url)

        # 2) Active — intentionally malicious-looking payload
        active_results: list[WAFResult] = []
        if active:
            active_results = await self._active_probe(url)
            for ar in active_results:
                ar.active = True

        all_results = self._merge(passive_results, active_results)

        if not all_results:
            self.logger.info("No WAF detected")
            return None

        best = max(all_results, key=lambda r: r.confidence)
        if best.confidence < self.CONFIDENCE_THRESHOLD:
            self.logger.info(
                f"Low-confidence WAF signature ({best.name}, "
                f"score={best.confidence}) — reporting as unknown"
            )
            return None

        self.logger.success(
            f"WAF detected: {best.name} "
            f"(confidence={best.confidence}, "
            f"active={'yes' if best.active else 'no'})"
        )
        return best

    # ── Detection helpers ──────────────────────────────────────────────────────

    async def _passive_probe(self, url: str) -> list[WAFResult]:
        resp = await self.http_client.get(url)
        if not resp:
            return []
        return self._analyse(resp, active=False)

    async def _active_probe(self, url: str) -> list[WAFResult]:
        results: list[WAFResult] = []
        base = url.rstrip("/")
        for suffix in _PROBE_PATHS:
            probe_url = base + suffix
            try:
                resp = await self.http_client.get(probe_url)
                if resp:
                    hits = self._analyse(resp, active=True)
                    results.extend(hits)
            except Exception:
                pass
        return results

    def _analyse(self, resp, *, active: bool) -> list[WAFResult]:
        headers    = {k.lower(): v.lower() for k, v in resp.headers.items()}
        set_cookie = headers.get("set-cookie", "")
        try:
            import asyncio
            body = asyncio.get_event_loop().run_until_complete(resp.text())
        except Exception:
            body = resp.text_sync() if hasattr(resp, "text_sync") else ""
        body = body.lower()

        results: list[WAFResult] = []

        for waf_name, sig in _SIGNATURES.items():
            score   = 0
            signals = []
            w       = sig.get("weights", {})

            # Header match
            hdr_weight = w.get("headers", 20)
            for hdr in sig["headers"]:
                if hdr in headers:
                    points = hdr_weight // max(len(sig["headers"]), 1)
                    score += points
                    signals.append(f"header:{hdr}")

            # Cookie match
            ck_weight = w.get("cookies", 20)
            for ck in sig["cookies"]:
                if ck in set_cookie:
                    points = ck_weight // max(len(sig["cookies"]), 1)
                    score += points
                    signals.append(f"cookie:{ck}")

            # Body match (regex)
            body_weight = w.get("body", 30)
            body_sigs   = sig.get("body", [])
            for pat in body_sigs:
                if re.search(pat, body):
                    points = body_weight // max(len(body_sigs), 1)
                    score += points
                    signals.append(f"body:{pat[:40]}")

            # Status code
            if resp.status in sig.get("status", []):
                score += w.get("status", 5)
                signals.append(f"status:{resp.status}")

            # Active probe bonus (block page on canary = stronger signal)
            if active and resp.status in (403, 406, 429, 503):
                score += 10
                signals.append("active_block")

            if score > 0:
                results.append(WAFResult(
                    name=waf_name,
                    confidence=min(score, 100),
                    signals=signals,
                ))

        return [r for r in results if r.confidence >= 10]

    @staticmethod
    def _merge(
        passive: list[WAFResult],
        active: list[WAFResult],
    ) -> list[WAFResult]:
        """Combine passive + active results, summing confidence per WAF name."""
        combined: dict[str, WAFResult] = {}
        for r in passive + active:
            if r.name in combined:
                combined[r.name].confidence = min(
                    100,
                    combined[r.name].confidence + r.confidence // 2,
                )
                combined[r.name].signals.extend(r.signals)
                combined[r.name].active = combined[r.name].active or r.active
            else:
                combined[r.name] = WAFResult(
                    name=r.name,
                    confidence=r.confidence,
                    signals=list(r.signals),
                    active=r.active,
                )
        return sorted(combined.values(), key=lambda x: x.confidence, reverse=True)
